# -*- coding: utf-8 -*-
##############################################################################
#
#    Odoo, Open Source Enterprise Management Solution, third party addon
#    Copyright (C) 2018 Vertel AB (<http://vertel.se>).
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################
from odoo import api, fields, models, _, exceptions
from odoo.osv import expression
from datetime import datetime
import time
from dateutil.relativedelta import relativedelta
from odoo.exceptions import Warning

import logging
_logger = logging.getLogger(__name__)


class account_model(models.Model):
    _name = 'account.model'
    _description = 'Account Model'

    name = fields.Char(string='Model Name', required=True, help='This is a model for recurring accounting entries')
    journal_id = fields.Many2one(comodel_name='account.journal', string='Journal', required=True)
    company_id = fields.Many2one(comodel_name='res.company', related='journal_id.company_id', string='Company', store=True, readonly=True)
    lines_id = fields.One2many(comodel_name='account.model.line', inverse_name='model_id', string='Model Entries', copy=True)
    legend = fields.Text(string='Legend', default=lambda self: _('You can specify year, month and date in the name of the model using the following labels:\n\n%(year)s: To Specify Year \n%(month)s: To Specify Month \n%(date)s: Current Date\n\ne.g. My model on %(date)s'), readonly=True, size=100)

    @api.multi
    def generate(self, data=None):
        if data is None:
            data = {}
        account_move_obj = self.env['account.move']
        moves = account_move_obj.browse()
        account_move_line_obj = self.env['account.move.line']
        pt_obj = self.env['account.payment.term']

        context = dict(self._context or {})

        if data.get('date', False):
            context = dict(self._context)
            context.update({'date': data['date']})

        move_date = context.get('date', fields.Date.today())
        for model in self:
            context.update({'company_id': model.company_id.id})
            context.update({'journal_id': model.journal_id.id})
            try:
                ref = data.get('ref', '') % {'year': move_date[:4], 'month': move_date[5:7], 'date': move_date[:7]}
            except:
                raise Warning(_('You have a wrong expression "%(...)s" in your reference: ') + data.get('ref', ''))
            move = account_move_obj.create({
                'ref': ref,
                'journal_id': model.journal_id.id,
                'date': context.get('date', fields.Date.context_today(model))
            })
            moves |= move
            line_vals = []
            for line in model.lines_id:
                analytic_account_id = False
                if line.analytic_account_id:
                    if not model.journal_id.analytic_journal_id:
                        raise Warning(_("You have to define an analytic journal on the '%s' journal!") % (model.journal_id.name,))
                    analytic_account_id = line.analytic_account_id.id
                val = {
                    'move_id': move.id,
                    'journal_id': model.journal_id.id,
                    'analytic_account_id': analytic_account_id
                }

                date_maturity = context.get('date', fields.Date.today())
                if line.date_maturity == 'partner':
                    if not line.partner_id:
                        raise Warning(_("Maturity date of entry line generated by model line '%s' of model '%s' is based on partner payment term!" \
                                                                "\nPlease define partner on it!")%(line.name, model.name))

                    payment_term_id = False
                    if model.journal_id.type in ('purchase', 'purchase_refund') and line.partner_id.property_supplier_payment_term:
                        payment_term_id = line.partner_id.property_supplier_payment_term.id
                    elif line.partner_id.property_payment_term:
                        payment_term_id = line.partner_id.property_payment_term.id
                    if payment_term_id:
                        pterm_list = pt_obj.compute(payment_term_id, value=1, date_ref=date_maturity)
                        if pterm_list:
                            pterm_list = [l[0] for l in pterm_list]
                            pterm_list.sort()
                            date_maturity = pterm_list[-1]

                val.update({
                    'name': line.name,
                    'quantity': line.quantity,
                    'debit': line.debit,
                    'credit': line.credit,
                    'account_id': line.account_id.id,
                    'partner_id': line.partner_id.id,
                    'tax_line_id': line.tax_line_id and line.tax_line_id.id,
                    'tax_ids': [(6, 0, [t.id for t in line.tax_ids])],
                    'date': context.get('date', fields.Date.context_today(model)),
                    'date_maturity': date_maturity
                })
                line_vals.append((0, 0, val))
            move.write({
                'line_ids': line_vals,
            })

        return moves

    #~ @api.onchange('journal_id')
    #~ def onchange_journal_id(self):
        #~ if self.journal_id and self.journal_id.company_id:
            #~ self.company_id = self.journal_id.company_id.id


class account_model_line(models.Model):
    _name = 'account.model.line'
    _description = 'Account Model Entries'
    _order = 'sequence'

    name = fields.Char(string='Name', required=True)
    sequence = fields.Integer(string='Sequence', required=True, help='The sequence field is used to order the resources from lower sequences to higher ones.')
    quantity = fields.Float(string='Quantity', digits=(16,4), help='The optional quantity on entries.')
    debit = fields.Float(string='Debit', digits=(16,4))
    credit = fields.Float(string='Credit', digits=(16,4))
    account_id = fields.Many2one(comodel_name='account.account', string='Account', required=True, ondelete='cascade')
    analytic_account_id = fields.Many2one(comodel_name='account.analytic.account', string='Analytic Account', ondelete='cascade')
    model_id = fields.Many2one(comodel_name='account.model', string='Model', required=True, ondelete="cascade")
    amount_currency = fields.Float(string='Amount Currency', help='The amount expressed in an optional other currency.')
    currency_id = fields.Many2one(comodel_name='res.currency', string='Currency')
    partner_id = fields.Many2one(comodel_name='res.partner', string='Partner')
    date_maturity = fields.Selection(selection=[('today','Date of the day'), ('partner','Partner Payment Term')], string='Maturity Date', help='The maturity date of the generated entries for this model. You can choose between the creation date or the creation date of the entries plus the partner payment terms.')
    tax_line_id = fields.Many2one(comodel_name='account.tax', string='Originator tax')
    tax_ids = fields.Many2many(comodel_name='account.tax', string='Taxes')

    _sql_constraints = [
        ('credit_debit1', 'CHECK (credit*debit=0)',  'Wrong credit or debit value in model, they must be positive!'),
        ('credit_debit2', 'CHECK (credit+debit>=0)', 'Wrong credit or debit value in model, they must be positive!'),
    ]


class account_subscription(models.Model):
    _name = 'account.subscription'
    _description = 'Account Subscription'

    name = fields.Char(string='Name', required=True)
    ref = fields.Char(string='Reference', required=True)
    model_id = fields.Many2one(comodel_name='account.model', string='Model', required=True)
    date_start = fields.Date(string='Start Date', default=lambda *a: fields.Date.today(), required=True)
    period_total = fields.Integer(string='Number of Entries', default=12, required=True, help="The total amount of entries that will be generated.")
    period_nbr = fields.Integer(string='Period length', default=1, required=True, help="The amount of time between each entry.")
    period_type = fields.Selection(selection=[('day','days'),('month','month'),('year','year')], string='Period Unit', default='month', required=True, help="The unit of the time between each entry.")
    state = fields.Selection(selection=[('draft','Draft'),('running','Running'),('done','Done')], string='Status', default='draft', required=True, readonly=True, copy=False)
    lines_id = fields.One2many(comodel_name='account.subscription.line', inverse_name='subscription_id', string='Subscription Lines', copy=True)

    @api.onchange('model_id')
    def onchange_model_id(self):
        self.ref = self.model_id.name if self.model_id else ''

    @api.multi
    def state_draft(self):
        self.write({'state':'draft'})
        return False

    @api.multi
    def check(self):
        todone = []
        for sub in self:
            ok = True
            for line in sub.lines_id:
                if not line.move_id.id:
                    ok = False
                    break
            if ok:
                todone.append(sub.id)
        if todone:
            self.write({'state':'done'})
        return False

    @api.multi
    def remove_line(self):
        toremove = []
        for sub in self:
            for line in sub.lines_id:
                if not line.move_id.id:
                    toremove.append(line.id)
        if toremove:
            self.env['account.subscription.line'].browse(toremove).unlink()
        self.write({'state':'draft'})
        return False

    @api.multi
    def compute(self):
        for sub in self:
            ds = sub.date_start
            for i in range(sub.period_total):
                self.env['account.subscription.line'].create({
                    'date': ds,
                    'subscription_id': sub.id,
                })
                if sub.period_type == 'day':
                    ds = fields.Date.to_string(fields.Date.from_string(ds) + relativedelta(days=sub.period_nbr))
                if sub.period_type == 'month':
                    ds = fields.Date.to_string(fields.Date.from_string(ds) + relativedelta(months=sub.period_nbr))
                if sub.period_type == 'year':
                    ds = fields.Date.to_string(fields.Date.from_string(ds) + relativedelta(years=sub.period_nbr))
        self.write({'state':'running'})
        return True


class account_subscription_line(models.Model):
    _name = 'account.subscription.line'
    _description = 'Account Subscription Line'

    subscription_id = fields.Many2one(comodel_name='account.subscription', string='Subscription', required=True, select=True)
    date = fields.Date(string='Date', required=True)
    move_id = fields.Many2one(comodel_name='account.move', string='Entry')

    @api.multi
    def move_create(self):
        tocheck = {}
        all_moves = self.env['account.move'].browse()
        obj_model = self.env['account.model']
        for line in self:
            data = {
                'date': line.date,
                'ref': line.subscription_id.ref,
            }
            moves = line.subscription_id.model_id.generate(data)
            tocheck[line.subscription_id.id] = True
            line.write({'move_id': moves[0].id})
            all_moves |= moves
        if tocheck:
            self.env['account.subscription'].browse(tocheck.keys()).check()
        return all_moves

    _rec_name = 'date'
